# faster-git打卡-Task02

## [faster-git/lecture03 at main · datawhalechina/faster-git](https://github.com/datawhalechina/faster-git/tree/main/lecture03)

> 第三章 Git分支管理

> 3.1 分支的简介

> 有的人将 Git 的分支模型称为它的“必杀技特性”

> 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并

> 理解和精通这一特性

> 3.2 分支的相关操作

> 3.2.1 分支的创建

> Git分支的创建十分简单，我们可以使用git branch来查看现有的分支或创建新的分支。当不带任何命令参数时，输入git branch可以帮助我们查看当前项目所拥有的全部分支。并且Git会使用*来标明我们当前所处的分支上。

> 当我们想要新增加新的分支时，只需要在git branch命令后面加上我们想要新建的分支的名称即可。

> 3.2.2 分支的切换

> 通过git checkout命令切换

> 分支上的文件状态是不同的。

> 分支上的记录与master的记录间隔开了

> 3.2.3 分支的合并

> 切换回主分支

> git checkout master

> 使用git merge 进行合并

> git merge issue102

> git branch --no-merged

> 查看所有未合并工作的分支

> 合并冲突

> 可以通过git status查看命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。当出现矛盾后，合并的文件内容将会出现"<<<<<<","=======",">>>>>>"等分割线来进行标记。

> 当出现了矛盾时，我们需要进行手动解决或者放弃合并。

> 手动合并

> 手动合并的方法很简单，就是我们选择我们要保留的代码，然后再把>>>>>, ======, <<<<<<这些提示行给去掉。最后重新进行add commit的操作即可。

> 放弃合并

> 当我们发现冲突所导致的改动量很大时，我们可以选择放弃该次的合并。我们可以使用git merge --abort放弃此次的融合。如果我们在运行了git merge之后又进行了一些人为的改动，那么在abort之后，所进行的改动也会被回滚掉。

> mergetool

> 除了手动合并以及放弃合并之外，我们还有一些其他的合并工具。git官方开发了一个专门用来合并的工具，叫做git mergetool(下图所示)，它会将找到一份两个分支的祖先代码作为base（基准），然后再将两个分支的改动都列举出来作为对比，让我们在git编辑器当中决定要留下什么。在此处，我们不做过多的阐述，感兴趣的同学可以点击下方链接进行查看。

> Use vimdiff as git mergetool

> 使用vimdiff作为git mergetool

> git-mergetool

> 3.2.4 分支推送到远程

> 使用git remote -v查看远程库的详细信息

> 当我们需要推送本地分支到远程时，需要指定具体的本地分支。

> 但是当我们多人协作进行开发的时候，可能会出现远程分支比我们本地更新的情况，这时，我们就需要使用git pull的命令来试图合并。如果合并出现冲突时，我们需要解决冲突再提交。在这部分，推荐大家可以看下廖雪峰老师的Git教程中的 多人协作，

> 3.2.5 分支的删除

> 在Git中没有什么分支是不可以删除的（除了当前所在的分支不能删除），包括master分支也是可以进行删除。 Git的分支删除可以分为删除本地分支和远程分支。

> 删除本地分支

> 强行删除分支

> 删除远程分支

> 3.2.6 分支的重命名

> 3.3 分支开发工作流

> 当我们已经了解了分支的操作后，我们应该考虑使用一种怎样的方式使我们最大化的使用分支操作的优点。

> 在整个项目开发周期的不同阶段，我们可以同时拥有多个分支；然后我们可以定期地把某些主题分支合并入其他分支中

> 许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。这样，在确保这些已完成的主题分支（短期分支，比如之前的 issue102 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。

> 3.3.2 短期分支

> 短期分支也可以叫做主题分支，它的作用是用来实现某一种特性或者相关工作（修复bug，开发产品新特性）

> 在实际开发中，我们应该按照以下几个基本原则进行分支开发工作流程

> master分支应该是最稳定的，也就是仅用来发布新版本，平时不能直接在上面进行操作，应该保存在远程。

> 短期分支是我们干活的分支，短期分支可以不用上传到远程，当我们完成了bug的修复，新功能的开发时才需要合并到主分支上。

> 多使用分支来进行开发工作。



## [faster-git/lecture04 at main · datawhalechina/faster-git](https://github.com/datawhalechina/faster-git/tree/main/lecture04)

> 第四章 Git 工具

> 本章主要介绍 Git 常用的工具，

> 4.1 引用修订版本

> Git 支持多种方式来引用单个提交、一组提交或一定范围内的提交。

> 4.1.1 引用 Commit 的记录

> 你可以通过任意一个提交的 40 位字符的 SHA-1散列值来指定它。

> 执行 git log 能看到类似提交日志的输出。(shell 通过 pipe | 将输出信息传递给 more 做多页显示)。

> $ git log | more

> 想查看某次提交信息，可以通过 git show 来查看，

> 查看所有所有提交 SHA-1 字符串

> $ git log|grep '^commit'|awk '{print $2}'

> Git 非常聪明的知道在没有歧义的情况下，通过前几个字符来替代上述 40 位字符，

> 在 git log 后加  --abbrev-commit 参数，

> 默认情况使用 7 个字符，有时为来避免歧义，会增加字符数。

> 通过在 git log后增加 --pretty=oneline简化输出内容

> 4.1.2 引用分支

> 查看本地分支列表通过git branch查看

> 查看远程分支通过后加参数-r

> git show stable查看指定分支最后一次提交信息

> 如果你的 branch 的名称和当前目录名称很不巧的重名了，那么应该会出现意外的输出

> Git 不知道如何处理，我们需要通过 -- 明确告知.

> -- 前面的为 revision 可以是分支，tag 等

> -- 后面的为 file 即要操作的文件

> 通过 git rev-parse可以查看某个分支指向那个特定的 SHA-1, 并通过 git show 去查看这个 SHA-1 值对应的提交信息。

> 4.1.3 引用日志

> 当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。 你可以使用 git reflog 来查看引用日志

> 如果你想查看仓库中 HEAD 在 2 次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。

> 4.2 交互式暂存

> 当你修改大量文件后，希望将改动拆分成多个提交而不是一起提交的时候，可以通过如下命令操作。

> 如果运行 git add 后加 -i 或者 --interactive 选项的时候，Git 会进入一个交互式命令模式，

> 这个命令以和平时不同的视图：显示了暂存区。基本上与 git status 是相同的信息，但是更简明扼要一些。

> 在这块区域后是 Commands 命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。

> 4.2.1 暂存、取消文件

> 在 Waht now>> 提示符后输入u或者2，它会提示你要暂存哪个文件

> 如果想取消暂存，在 Waht now>> 提示符后输入r或者3，进行撤销，

> 如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。

> 这跟你在命令行指定 git diff --cached 非常相似：

> 通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。

> 4.2.2 暂存补丁

> Git 也可以暂存文件的特定部分。

> 输入 p 或 5。

> 4.3 贮藏与清理

> 很多时候，你在当前分支上工作了一段时间后，东西变得很混乱。你想切换至新的分支而又不想放弃放弃的修改，或者纯粹想先做其他分支的事情的时候，就该git stash上场了。

> stash 会处理工作目录的的状态，跟踪文件的修改和暂存的改动，然后将未完成的修改保存至一个栈上，这样就可以在后续任何时间切换回来。

> 运行git stash 或者 git stash push

> 那么要返回刚才那坨文件该怎么办呢？通过 git stash list 查看所有 stash 的列表

> 切换至最后 stash 变更，直接执行 git stash apply 即可，当然如果有多个，可以通过 git stash apply stash@{n} 中的 n 来获取指定的的变更。

> 可以通过 git stash drop 或者 git stash pop 来删除 stash 的内容。

> 4.3.2 清理工作目录

> 对于一些不需要的文件或目录，你需要的是清理它而不是保存修改记录，git clean就是用来做这个事情的

> 需要注意的是，这个命令会移除未被跟踪的文件，可以考虑执行 git stash --all 来移除所有文件并保存到栈上。

> 使用 git clean -f -d 命令来移除工作目录中所有未追踪的文件以及空的子目录。 -f 意味着强制移除，使用它需要 Git 配置变量 clean.requireForce 没有显式设置为 false。

> 如果你只是想看下或者删除前小心翼翼的确认: 它到底会删除那些东西. 可以通过--dry-run或者-n选项来执行命令，这只是告诉你会删除什么，而不会真的删除.

> 默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitignore 或其他忽略文件中的模式匹配的文件都不会被移除。如果你也想移除，可以通过增加选项-x

> 同样增加选项-d可以删除目录

> 如果你想交互删除，可以通过选项 -i来操作

> 通过What now后输入命令或序号交互操作，不知道可以输入 help 查看具体的描述

> 4.4 搜索

> 无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者显示一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。

> 4.4.1 Git Grep

> Git 提供了一个grep命令，可以很方便的从提交历史，工作目录，甚至索引中查找一个字符串或者正则表达式。

> 默认情况下git grep会查找你的工作目录文件。

> 通过-n或者--line-number显示匹配的行号

> 通过-c或者--count输出统计信息

> 通过-p 或者 --show-function  显示每个匹配字符串所在的方法或函数

> 4.4.2 Git 日志搜索

> 通过git log可以很强大的知道一些特定的提交信息。

> 通过-S选项知道内容的新增和删除提交记录，

> 通过-L选项进行行日志搜索，它可以展示代码中一行或者一个函数的历史。

> 如果 Git 无法匹配到你的函数或者方法，可以通过正则表达式，

> 如这个命令和上面是等效的

> 4.5 子模块

> 项目中经常会遇到包含另外一个项目，如：第三方库，或者你将自己的项目切分成多个子项目，然后在其他项目中引用，如，将项目中的 model 独立处理，独立维护；其他项目组引用这个项目，并不维护 model。这里我们可以将 model 做子项目添加到当前项目中。

> 4.5.1 添加子模块

> 通过 git submodule add 添加子模块,

> 参数同 clone，默认是 repo 的名称，如果你想改名，可以在后续增加新的名称或路径。

> 通过 git status 能看到新的 model 库。

> 能看到有个新增的 model 和 .gitmodules文件，该配置文件保存了项目 URL 和本地目录的 mapping 关系。

> 如果有多个子模块，这里会列出多条。

> 通过git diff能看到更详细的信息

> 虽然 model 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作子模块仓库中的某个具体的提交。

> 如果你想看到更漂亮的差异输出，可以给 git diff 传递 --submodule 选项。

> 注意 app 记录的 160000 模式。这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。

> 4.5.2 克隆含有子模块的项目

> 我们在 clone 一个含子模块的项目时，默认是不会包含子模块内容的，只有目录

> 需要通过如下两个命令来获取内容

> git submodule init 初始化本地配置文件

> git submodule update 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。

> 不过还有更简单一点的方式。 如果给 git clone 命令传递 --recurse-submodules 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。

> 如果你已经克隆了项目但忘记了 --recurse-submodules，那么可以运行 git submodule update --init  将 git submodule init 和 git submodule update 合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块， 请使用简明的 git submodule update --init --recursive。

> 4.5.2 更新子模块

> 当子模块有更新的时候，执行  git submodule update --remote

> 该命令默认会更新 main 分支，如果你想设置为其他分支，可以在 .gitmodules 文件中设置 （这样其他人也可以跟踪它），也可以只在本地的 .git/config 文件中设置，我们在.gitmodules中配置它

> 4.6 打包

> Git 提供了多种网络传输的方法，如 SSH、HTTP 等，但是还有种不太常用的功能又什么有效。

> Git 可以就将它的数据"打包"到一个文件中，通过 git bundle来实现。bundle 命令会将git push命令所传输的所有内容打包成一个二进制文件，你可以将这个文件转发给别人，然后解包到仓库中。

> 这个 repo.bundle 就是我打包之后的文件，改文件包含了所有重建仓库 main 分支所需要的数据。在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。

> 如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b main 或者其他被引入的分支， 否则 Git 不知道应该检出哪一个分支。

> 如果只是要提交最新提交的修改，这需要我们手工计算，可以通过如下的指令计算差别

> 这里将获得到我们希望被打包的提交列表，将这些提交打包，通过 git bundle create操作

> 4.7 总结

> 这里只是整理一些常用的工具，还有一些高级的功能，如签名、凭证存储、重置、Rerere 等功能，


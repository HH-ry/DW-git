# faster-git打卡-Task01：Git基础



## [faster-git/lecture02 at main · datawhalechina/faster-git](https://github.com/datawhalechina/faster-git/tree/main/lecture02)

> 第二章 Git基础命令

> 通常有两种获取 Git 项目仓库的方式：

> 将尚未进行版本控制的本地目录转换为 Git 仓库；

> 从其它服务器 克隆 一个已存在的 Git 仓库。

> 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。

> 2.1 获取 Git 仓库

> $ cd /c/user/my_project

> $ git init

> $ git add *.c

> $ git add LICENSE

> $ git commit -m 'initial project version'

> 克隆仓库的命令是 git clone

> $ git clone https://github.com/libgit2/libgit2

> 自定义本地仓库的名字

> $ git clone https://github.com/libgit2/libgit2 mylibgit

> 2.2 记录每次更新到仓库

> 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议

> 可以用 git status 命令查看哪些文件处于什么状态。

> 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：

> $ git status

> On branch master

> Your branch is up-to-date with 'origin/master'.

> nothing to commit, working directory clean

> 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过

> 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件

> 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离

> 2.2.2 跟踪新文件

> $ git add

> 2.2.3 暂存已修改的文件

> 运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来

> 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。

> 2.2.4 忽略文件

> 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。

> 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。



> $ cat .gitignore

> *.[oa]

> *~

> 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。

> 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，

> 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等

> 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

> 文件 .gitignore 的格式规范如下：

> 所有空行或者以 # 开头的行都会被 Git 忽略。

> 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。

> 匹配模式可以以（/）开头防止递归。

> 匹配模式可以以（/）结尾指定目录。

> 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。

> Tip GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。

> Note 在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个 .gitignore 文件。）

> 2.2.5 查看已暂存和未暂存的修改

> 想知道具体修改了什么地方，可以用 git diff 命令

> 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：

> 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。

> 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令

> 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。

> 使用 git difftool --tool-help 命令来看你的系统支持哪些 Git Diff 插件。

> 2.2.6 提交更新

> 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit：

> $ git commit 这样会启动你选择的文本编辑器来输入提交说明。

> Note 启动的编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。 当然也可以按照 起步 介绍的方式， 使用 git config --global core.editor 命令设置你喜欢的编辑器。

> 提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。

> 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。

> 2.2.7 跳过使用暂存区域

> Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：

> $ git commit -a -m 'added new benchmarks'

> 2.2.8 移除文件

> 从工作目录中手工删除文件

> 下一次提交时，该文件就不再纳入版本管理了。

> 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f

> 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 --cached 选项：

> $ git rm --cached README git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。

> 删除 log/ 目录下扩展名为 .log 的所有文件。

> 会删除所有名字以 ~ 结尾的文件。

> 2.2.9 移动文件

> 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，

> $ git mv

> git mv 是一条命令而非三条命令

> 2.3 查看提交历史

> 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。

> 这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。

> 其中一个比较有用的选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。

> 该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。

> git log 附带一系列的总结性选项。

> --stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。

> 另一个非常有用的选项是 --pretty。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：

> 作者 和 提交者 之间究竟有何差别

> 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：

> 2.3.1 限制输出长度

> --since

> -until

> Note 你可以指定多个 --author 和 --grep 搜索条件

> 另一个非常有用的过滤器是 -S（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。

> Table 3. 限制 git log 输出的选项 选项 说明 -仅显示最近的 n 条提交。

> --since, --after仅显示指定时间之后的提交。

> --until, --before仅显示指定时间之前的提交。

> --author仅显示作者匹配指定字符串的提交。

> --committer仅显示提交者匹配指定字符串的提交。

> --grep仅显示提交说明中包含指定字符串的提交。

> -S仅显示添加或删除内容匹配指定字符串的提交。

> 2.3.2 Tip

> 隐藏合并提交 按照你代码仓库的工作流程，记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 log 加上 --no-merges 选项。

> 2.4 撤消操作

> 可以运行带有 --amend 选项的提交命令来重新提交：

> 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。

> Note 当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 新的提交 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。

> 修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。

> 2.4.1 取消暂存的文件

> $ git reset HEAD

> Note git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。

> 2.4.2 撤消对文件的修改

> $ git checkout

> 2.4.3 Important

> 请务必记得 git checkout -- 是一个危险的命令。

> 记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。

> 2.5 远程仓库的使用



> 2.5.1 Note

> 远程仓库可以在你的本地主机上

> 2.5.2 查看远程仓库

> 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：

> https://github.com/schacon/ticgit

> 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。

> 如果你的远程仓库不止一个，该命令会将它们全部列出。

> 2.5.3 添加远程仓库

> git remote add

> 指定一个方便使用的简写：

> https://github.com/paulboone/ticgit

> 现在你可以在命令行中使用字符串 pb 来代替整个 URL。

> 拉取

> git fetch

> 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中

> 从远程仓库中抓取与拉取

> $ git fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。

> 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。

> 如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。

> 2.5.4 推送到远程仓库

> $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。

> git remote show

> 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。

> 2.5.5 远程仓库的重命名与移除

> git remote rename

> git remote remove

> git remote rm

> 2.6 打标签

> 2.6.1 列出标签

> git tag （可带上可选的 -l 选项 --list）

> 2.6.2 创建标签

> Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。

> 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。

> 而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，

> 2.6.3 附注标签

> 在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：

> git show 命令可以看到标签信息和与之对应的提交信息：

> 另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：

> 2.6.5 后期打标签

> 9fceb02

> 9fceb02

> 2.6.6 共享标签

> 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin 。

> 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。

> 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。

> Note git push 推送两种标签 使用 git push --tags 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。

> 2.6.7 删除标签

> 要删除掉你本地仓库上的标签，可以使用命令 git tag -d 。

> $ git tag -d v1.4-lw Deleted tag 'v1.4-lw' (was e7d5add) 注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push :refs/tags/ 来更新你的远程仓库：

> 第一种变体是 git push :refs/tags/ ：

> [deleted] v1.4-lw 上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。

> 第二种更直观的删除远程标签的方式是：

> $ git push origin --delete

> 2.6.8 检出标签

> 如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：

> 在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：

> 如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。

> 2.7 Git 别名

> 可以通过 git config 文件来轻松地为每一个命令设置一个别名。

> 可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号

